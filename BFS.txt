leetcode994  腐烂的橘子


    BFS广度优先搜索，一般需要借助队列来实现，将起始点入队，然后循环出队，
将出队的点周围符合条件的点入队，直到队列为空。

    队列queue位于<queue>头文件中，需要包含该头文件。它属于STL（标准模板库），
是deque（或者list）等封装而来的适配器。
    queue的常用函数有：
    push()：将元素压入队列
    pop()：将队首元素弹出
    front()：返回队首元素
    empty()：判断队列是否为空
    size()：返回队列中元素个数
    queue的初始化：queue<int> q;

    “逐层”BFS对应于树的层次遍历，而“多源”BFS对应于图的广度优先搜索。
    template <typename T>
    void bfs(T root) {
        queue<T> q;
        q.push(root);
        while (!q.empty()) {
            int qsize=q.size();
            for (int i = 0; i < qsize; ++i){    
                T node = q.front();             
                q.pop();                        //当前层元素出队
                if(node……){
                    q.push(node……);             //下层元素入队
                }
            }
        }
    }

leetcode994  腐烂的橘子
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：
值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。
返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

本质是一个bfs问题，将腐烂的橘子入队，然后进行bfs，将周围的橘子腐烂，
同时将新鲜橘子数量减一，最后判断新鲜橘子数量是否为0，为0则返回时间，否则返回-1。
需要注意对新鲜橘子计数，因为需要将二维坐标作为元素入队
所以使用到了pair与make_pair函数
class Solution {
public:
    int directions[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
    int orangesRotting(vector<vector<int>>& grid) {
        int m=grid.size(),n=grid[0].size();
        int fresh=0;
        queue<pair<int,int>> q;
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(grid[i][j]==1){
                    ++fresh;
                }else if(grid[i][j]==2){
                    q.push(make_pair(i,j));
                }
            }
        }
        int minute=-1;
        while(!q.empty()){
            ++minute;
            int qsize=q.size();
            for(int i=0;i<qsize;++i){
                pair<int,int> tmp=q.front();
                q.pop();
                for(int j=0;j<4;++j){
                    int x=tmp.first+directions[j][0];
                    int y=tmp.second+directions[j][1];
                    if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]==1){
                        --fresh;
                        grid[x][y]=2;
                        q.push(make_pair(x,y));
                    }
                }
            }
        }
        return fresh>0? -1:max(minute,0);
    }
};
